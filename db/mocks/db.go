// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	big "math/big"

	coretypes "github.com/ethereum/go-ethereum/core/types"

	mock "github.com/stretchr/testify/mock"

	models "github.com/dan13ram/wpokt-oracle/models"

	primitive "go.mongodb.org/mongo-driver/bson/primitive"

	types "github.com/cosmos/cosmos-sdk/types"
)

// MockDB is an autogenerated mock type for the DB type
type MockDB struct {
	mock.Mock
}

type MockDB_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDB) EXPECT() *MockDB_Expecter {
	return &MockDB_Expecter{mock: &_m.Mock}
}

// FindMaxSequence provides a mock function with given fields: chain
func (_m *MockDB) FindMaxSequence(chain models.Chain) (*uint64, error) {
	ret := _m.Called(chain)

	if len(ret) == 0 {
		panic("no return value specified for FindMaxSequence")
	}

	var r0 *uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Chain) (*uint64, error)); ok {
		return rf(chain)
	}
	if rf, ok := ret.Get(0).(func(models.Chain) *uint64); ok {
		r0 = rf(chain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(models.Chain) error); ok {
		r1 = rf(chain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_FindMaxSequence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindMaxSequence'
type MockDB_FindMaxSequence_Call struct {
	*mock.Call
}

// FindMaxSequence is a helper method to define mock.On call
//   - chain models.Chain
func (_e *MockDB_Expecter) FindMaxSequence(chain interface{}) *MockDB_FindMaxSequence_Call {
	return &MockDB_FindMaxSequence_Call{Call: _e.mock.On("FindMaxSequence", chain)}
}

func (_c *MockDB_FindMaxSequence_Call) Run(run func(chain models.Chain)) *MockDB_FindMaxSequence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Chain))
	})
	return _c
}

func (_c *MockDB_FindMaxSequence_Call) Return(_a0 *uint64, _a1 error) *MockDB_FindMaxSequence_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_FindMaxSequence_Call) RunAndReturn(run func(models.Chain) (*uint64, error)) *MockDB_FindMaxSequence_Call {
	_c.Call.Return(run)
	return _c
}

// FindMessage provides a mock function with given fields: filter
func (_m *MockDB) FindMessage(filter primitive.M) (models.Message, error) {
	ret := _m.Called(filter)

	if len(ret) == 0 {
		panic("no return value specified for FindMessage")
	}

	var r0 models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(primitive.M) (models.Message, error)); ok {
		return rf(filter)
	}
	if rf, ok := ret.Get(0).(func(primitive.M) models.Message); ok {
		r0 = rf(filter)
	} else {
		r0 = ret.Get(0).(models.Message)
	}

	if rf, ok := ret.Get(1).(func(primitive.M) error); ok {
		r1 = rf(filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_FindMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindMessage'
type MockDB_FindMessage_Call struct {
	*mock.Call
}

// FindMessage is a helper method to define mock.On call
//   - filter primitive.M
func (_e *MockDB_Expecter) FindMessage(filter interface{}) *MockDB_FindMessage_Call {
	return &MockDB_FindMessage_Call{Call: _e.mock.On("FindMessage", filter)}
}

func (_c *MockDB_FindMessage_Call) Run(run func(filter primitive.M)) *MockDB_FindMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(primitive.M))
	})
	return _c
}

func (_c *MockDB_FindMessage_Call) Return(_a0 models.Message, _a1 error) *MockDB_FindMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_FindMessage_Call) RunAndReturn(run func(primitive.M) (models.Message, error)) *MockDB_FindMessage_Call {
	_c.Call.Return(run)
	return _c
}

// FindNode provides a mock function with given fields: filter
func (_m *MockDB) FindNode(filter interface{}) (*models.Node, error) {
	ret := _m.Called(filter)

	if len(ret) == 0 {
		panic("no return value specified for FindNode")
	}

	var r0 *models.Node
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}) (*models.Node, error)); ok {
		return rf(filter)
	}
	if rf, ok := ret.Get(0).(func(interface{}) *models.Node); ok {
		r0 = rf(filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Node)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}) error); ok {
		r1 = rf(filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_FindNode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindNode'
type MockDB_FindNode_Call struct {
	*mock.Call
}

// FindNode is a helper method to define mock.On call
//   - filter interface{}
func (_e *MockDB_Expecter) FindNode(filter interface{}) *MockDB_FindNode_Call {
	return &MockDB_FindNode_Call{Call: _e.mock.On("FindNode", filter)}
}

func (_c *MockDB_FindNode_Call) Run(run func(filter interface{})) *MockDB_FindNode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockDB_FindNode_Call) Return(_a0 *models.Node, _a1 error) *MockDB_FindNode_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_FindNode_Call) RunAndReturn(run func(interface{}) (*models.Node, error)) *MockDB_FindNode_Call {
	_c.Call.Return(run)
	return _c
}

// GetBroadcastedMessages provides a mock function with given fields: chain
func (_m *MockDB) GetBroadcastedMessages(chain models.Chain) ([]models.Message, error) {
	ret := _m.Called(chain)

	if len(ret) == 0 {
		panic("no return value specified for GetBroadcastedMessages")
	}

	var r0 []models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Chain) ([]models.Message, error)); ok {
		return rf(chain)
	}
	if rf, ok := ret.Get(0).(func(models.Chain) []models.Message); ok {
		r0 = rf(chain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(models.Chain) error); ok {
		r1 = rf(chain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_GetBroadcastedMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBroadcastedMessages'
type MockDB_GetBroadcastedMessages_Call struct {
	*mock.Call
}

// GetBroadcastedMessages is a helper method to define mock.On call
//   - chain models.Chain
func (_e *MockDB_Expecter) GetBroadcastedMessages(chain interface{}) *MockDB_GetBroadcastedMessages_Call {
	return &MockDB_GetBroadcastedMessages_Call{Call: _e.mock.On("GetBroadcastedMessages", chain)}
}

func (_c *MockDB_GetBroadcastedMessages_Call) Run(run func(chain models.Chain)) *MockDB_GetBroadcastedMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Chain))
	})
	return _c
}

func (_c *MockDB_GetBroadcastedMessages_Call) Return(_a0 []models.Message, _a1 error) *MockDB_GetBroadcastedMessages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_GetBroadcastedMessages_Call) RunAndReturn(run func(models.Chain) ([]models.Message, error)) *MockDB_GetBroadcastedMessages_Call {
	_c.Call.Return(run)
	return _c
}

// GetBroadcastedRefunds provides a mock function with given fields:
func (_m *MockDB) GetBroadcastedRefunds() ([]models.Refund, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBroadcastedRefunds")
	}

	var r0 []models.Refund
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]models.Refund, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []models.Refund); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Refund)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_GetBroadcastedRefunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBroadcastedRefunds'
type MockDB_GetBroadcastedRefunds_Call struct {
	*mock.Call
}

// GetBroadcastedRefunds is a helper method to define mock.On call
func (_e *MockDB_Expecter) GetBroadcastedRefunds() *MockDB_GetBroadcastedRefunds_Call {
	return &MockDB_GetBroadcastedRefunds_Call{Call: _e.mock.On("GetBroadcastedRefunds")}
}

func (_c *MockDB_GetBroadcastedRefunds_Call) Run(run func()) *MockDB_GetBroadcastedRefunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDB_GetBroadcastedRefunds_Call) Return(_a0 []models.Refund, _a1 error) *MockDB_GetBroadcastedRefunds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_GetBroadcastedRefunds_Call) RunAndReturn(run func() ([]models.Refund, error)) *MockDB_GetBroadcastedRefunds_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfirmedTransactionsTo provides a mock function with given fields: chain, toAddress
func (_m *MockDB) GetConfirmedTransactionsTo(chain models.Chain, toAddress []byte) ([]models.Transaction, error) {
	ret := _m.Called(chain, toAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetConfirmedTransactionsTo")
	}

	var r0 []models.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Chain, []byte) ([]models.Transaction, error)); ok {
		return rf(chain, toAddress)
	}
	if rf, ok := ret.Get(0).(func(models.Chain, []byte) []models.Transaction); ok {
		r0 = rf(chain, toAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(models.Chain, []byte) error); ok {
		r1 = rf(chain, toAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_GetConfirmedTransactionsTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfirmedTransactionsTo'
type MockDB_GetConfirmedTransactionsTo_Call struct {
	*mock.Call
}

// GetConfirmedTransactionsTo is a helper method to define mock.On call
//   - chain models.Chain
//   - toAddress []byte
func (_e *MockDB_Expecter) GetConfirmedTransactionsTo(chain interface{}, toAddress interface{}) *MockDB_GetConfirmedTransactionsTo_Call {
	return &MockDB_GetConfirmedTransactionsTo_Call{Call: _e.mock.On("GetConfirmedTransactionsTo", chain, toAddress)}
}

func (_c *MockDB_GetConfirmedTransactionsTo_Call) Run(run func(chain models.Chain, toAddress []byte)) *MockDB_GetConfirmedTransactionsTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Chain), args[1].([]byte))
	})
	return _c
}

func (_c *MockDB_GetConfirmedTransactionsTo_Call) Return(_a0 []models.Transaction, _a1 error) *MockDB_GetConfirmedTransactionsTo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_GetConfirmedTransactionsTo_Call) RunAndReturn(run func(models.Chain, []byte) ([]models.Transaction, error)) *MockDB_GetConfirmedTransactionsTo_Call {
	_c.Call.Return(run)
	return _c
}

// GetPendingMessages provides a mock function with given fields: signerToExclude, chain
func (_m *MockDB) GetPendingMessages(signerToExclude string, chain models.Chain) ([]models.Message, error) {
	ret := _m.Called(signerToExclude, chain)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingMessages")
	}

	var r0 []models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, models.Chain) ([]models.Message, error)); ok {
		return rf(signerToExclude, chain)
	}
	if rf, ok := ret.Get(0).(func(string, models.Chain) []models.Message); ok {
		r0 = rf(signerToExclude, chain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, models.Chain) error); ok {
		r1 = rf(signerToExclude, chain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_GetPendingMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPendingMessages'
type MockDB_GetPendingMessages_Call struct {
	*mock.Call
}

// GetPendingMessages is a helper method to define mock.On call
//   - signerToExclude string
//   - chain models.Chain
func (_e *MockDB_Expecter) GetPendingMessages(signerToExclude interface{}, chain interface{}) *MockDB_GetPendingMessages_Call {
	return &MockDB_GetPendingMessages_Call{Call: _e.mock.On("GetPendingMessages", signerToExclude, chain)}
}

func (_c *MockDB_GetPendingMessages_Call) Run(run func(signerToExclude string, chain models.Chain)) *MockDB_GetPendingMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(models.Chain))
	})
	return _c
}

func (_c *MockDB_GetPendingMessages_Call) Return(_a0 []models.Message, _a1 error) *MockDB_GetPendingMessages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_GetPendingMessages_Call) RunAndReturn(run func(string, models.Chain) ([]models.Message, error)) *MockDB_GetPendingMessages_Call {
	_c.Call.Return(run)
	return _c
}

// GetPendingRefunds provides a mock function with given fields: signerToExclude
func (_m *MockDB) GetPendingRefunds(signerToExclude string) ([]models.Refund, error) {
	ret := _m.Called(signerToExclude)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingRefunds")
	}

	var r0 []models.Refund
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]models.Refund, error)); ok {
		return rf(signerToExclude)
	}
	if rf, ok := ret.Get(0).(func(string) []models.Refund); ok {
		r0 = rf(signerToExclude)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Refund)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(signerToExclude)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_GetPendingRefunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPendingRefunds'
type MockDB_GetPendingRefunds_Call struct {
	*mock.Call
}

// GetPendingRefunds is a helper method to define mock.On call
//   - signerToExclude string
func (_e *MockDB_Expecter) GetPendingRefunds(signerToExclude interface{}) *MockDB_GetPendingRefunds_Call {
	return &MockDB_GetPendingRefunds_Call{Call: _e.mock.On("GetPendingRefunds", signerToExclude)}
}

func (_c *MockDB_GetPendingRefunds_Call) Run(run func(signerToExclude string)) *MockDB_GetPendingRefunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockDB_GetPendingRefunds_Call) Return(_a0 []models.Refund, _a1 error) *MockDB_GetPendingRefunds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_GetPendingRefunds_Call) RunAndReturn(run func(string) ([]models.Refund, error)) *MockDB_GetPendingRefunds_Call {
	_c.Call.Return(run)
	return _c
}

// GetPendingTransactionsFrom provides a mock function with given fields: chain, fromAddress
func (_m *MockDB) GetPendingTransactionsFrom(chain models.Chain, fromAddress []byte) ([]models.Transaction, error) {
	ret := _m.Called(chain, fromAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingTransactionsFrom")
	}

	var r0 []models.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Chain, []byte) ([]models.Transaction, error)); ok {
		return rf(chain, fromAddress)
	}
	if rf, ok := ret.Get(0).(func(models.Chain, []byte) []models.Transaction); ok {
		r0 = rf(chain, fromAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(models.Chain, []byte) error); ok {
		r1 = rf(chain, fromAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_GetPendingTransactionsFrom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPendingTransactionsFrom'
type MockDB_GetPendingTransactionsFrom_Call struct {
	*mock.Call
}

// GetPendingTransactionsFrom is a helper method to define mock.On call
//   - chain models.Chain
//   - fromAddress []byte
func (_e *MockDB_Expecter) GetPendingTransactionsFrom(chain interface{}, fromAddress interface{}) *MockDB_GetPendingTransactionsFrom_Call {
	return &MockDB_GetPendingTransactionsFrom_Call{Call: _e.mock.On("GetPendingTransactionsFrom", chain, fromAddress)}
}

func (_c *MockDB_GetPendingTransactionsFrom_Call) Run(run func(chain models.Chain, fromAddress []byte)) *MockDB_GetPendingTransactionsFrom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Chain), args[1].([]byte))
	})
	return _c
}

func (_c *MockDB_GetPendingTransactionsFrom_Call) Return(_a0 []models.Transaction, _a1 error) *MockDB_GetPendingTransactionsFrom_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_GetPendingTransactionsFrom_Call) RunAndReturn(run func(models.Chain, []byte) ([]models.Transaction, error)) *MockDB_GetPendingTransactionsFrom_Call {
	_c.Call.Return(run)
	return _c
}

// GetPendingTransactionsTo provides a mock function with given fields: chain, toAddress
func (_m *MockDB) GetPendingTransactionsTo(chain models.Chain, toAddress []byte) ([]models.Transaction, error) {
	ret := _m.Called(chain, toAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingTransactionsTo")
	}

	var r0 []models.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Chain, []byte) ([]models.Transaction, error)); ok {
		return rf(chain, toAddress)
	}
	if rf, ok := ret.Get(0).(func(models.Chain, []byte) []models.Transaction); ok {
		r0 = rf(chain, toAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(models.Chain, []byte) error); ok {
		r1 = rf(chain, toAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_GetPendingTransactionsTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPendingTransactionsTo'
type MockDB_GetPendingTransactionsTo_Call struct {
	*mock.Call
}

// GetPendingTransactionsTo is a helper method to define mock.On call
//   - chain models.Chain
//   - toAddress []byte
func (_e *MockDB_Expecter) GetPendingTransactionsTo(chain interface{}, toAddress interface{}) *MockDB_GetPendingTransactionsTo_Call {
	return &MockDB_GetPendingTransactionsTo_Call{Call: _e.mock.On("GetPendingTransactionsTo", chain, toAddress)}
}

func (_c *MockDB_GetPendingTransactionsTo_Call) Run(run func(chain models.Chain, toAddress []byte)) *MockDB_GetPendingTransactionsTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Chain), args[1].([]byte))
	})
	return _c
}

func (_c *MockDB_GetPendingTransactionsTo_Call) Return(_a0 []models.Transaction, _a1 error) *MockDB_GetPendingTransactionsTo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_GetPendingTransactionsTo_Call) RunAndReturn(run func(models.Chain, []byte) ([]models.Transaction, error)) *MockDB_GetPendingTransactionsTo_Call {
	_c.Call.Return(run)
	return _c
}

// GetSignedMessages provides a mock function with given fields: chain
func (_m *MockDB) GetSignedMessages(chain models.Chain) ([]models.Message, error) {
	ret := _m.Called(chain)

	if len(ret) == 0 {
		panic("no return value specified for GetSignedMessages")
	}

	var r0 []models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Chain) ([]models.Message, error)); ok {
		return rf(chain)
	}
	if rf, ok := ret.Get(0).(func(models.Chain) []models.Message); ok {
		r0 = rf(chain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(models.Chain) error); ok {
		r1 = rf(chain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_GetSignedMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSignedMessages'
type MockDB_GetSignedMessages_Call struct {
	*mock.Call
}

// GetSignedMessages is a helper method to define mock.On call
//   - chain models.Chain
func (_e *MockDB_Expecter) GetSignedMessages(chain interface{}) *MockDB_GetSignedMessages_Call {
	return &MockDB_GetSignedMessages_Call{Call: _e.mock.On("GetSignedMessages", chain)}
}

func (_c *MockDB_GetSignedMessages_Call) Run(run func(chain models.Chain)) *MockDB_GetSignedMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Chain))
	})
	return _c
}

func (_c *MockDB_GetSignedMessages_Call) Return(_a0 []models.Message, _a1 error) *MockDB_GetSignedMessages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_GetSignedMessages_Call) RunAndReturn(run func(models.Chain) ([]models.Message, error)) *MockDB_GetSignedMessages_Call {
	_c.Call.Return(run)
	return _c
}

// GetSignedRefunds provides a mock function with given fields:
func (_m *MockDB) GetSignedRefunds() ([]models.Refund, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSignedRefunds")
	}

	var r0 []models.Refund
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]models.Refund, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []models.Refund); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Refund)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_GetSignedRefunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSignedRefunds'
type MockDB_GetSignedRefunds_Call struct {
	*mock.Call
}

// GetSignedRefunds is a helper method to define mock.On call
func (_e *MockDB_Expecter) GetSignedRefunds() *MockDB_GetSignedRefunds_Call {
	return &MockDB_GetSignedRefunds_Call{Call: _e.mock.On("GetSignedRefunds")}
}

func (_c *MockDB_GetSignedRefunds_Call) Run(run func()) *MockDB_GetSignedRefunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDB_GetSignedRefunds_Call) Return(_a0 []models.Refund, _a1 error) *MockDB_GetSignedRefunds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_GetSignedRefunds_Call) RunAndReturn(run func() ([]models.Refund, error)) *MockDB_GetSignedRefunds_Call {
	_c.Call.Return(run)
	return _c
}

// InsertMessage provides a mock function with given fields: tx
func (_m *MockDB) InsertMessage(tx models.Message) (primitive.ObjectID, error) {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for InsertMessage")
	}

	var r0 primitive.ObjectID
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Message) (primitive.ObjectID, error)); ok {
		return rf(tx)
	}
	if rf, ok := ret.Get(0).(func(models.Message) primitive.ObjectID); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(primitive.ObjectID)
		}
	}

	if rf, ok := ret.Get(1).(func(models.Message) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_InsertMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertMessage'
type MockDB_InsertMessage_Call struct {
	*mock.Call
}

// InsertMessage is a helper method to define mock.On call
//   - tx models.Message
func (_e *MockDB_Expecter) InsertMessage(tx interface{}) *MockDB_InsertMessage_Call {
	return &MockDB_InsertMessage_Call{Call: _e.mock.On("InsertMessage", tx)}
}

func (_c *MockDB_InsertMessage_Call) Run(run func(tx models.Message)) *MockDB_InsertMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Message))
	})
	return _c
}

func (_c *MockDB_InsertMessage_Call) Return(_a0 primitive.ObjectID, _a1 error) *MockDB_InsertMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_InsertMessage_Call) RunAndReturn(run func(models.Message) (primitive.ObjectID, error)) *MockDB_InsertMessage_Call {
	_c.Call.Return(run)
	return _c
}

// InsertRefund provides a mock function with given fields: tx
func (_m *MockDB) InsertRefund(tx models.Refund) (primitive.ObjectID, error) {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for InsertRefund")
	}

	var r0 primitive.ObjectID
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Refund) (primitive.ObjectID, error)); ok {
		return rf(tx)
	}
	if rf, ok := ret.Get(0).(func(models.Refund) primitive.ObjectID); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(primitive.ObjectID)
		}
	}

	if rf, ok := ret.Get(1).(func(models.Refund) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_InsertRefund_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertRefund'
type MockDB_InsertRefund_Call struct {
	*mock.Call
}

// InsertRefund is a helper method to define mock.On call
//   - tx models.Refund
func (_e *MockDB_Expecter) InsertRefund(tx interface{}) *MockDB_InsertRefund_Call {
	return &MockDB_InsertRefund_Call{Call: _e.mock.On("InsertRefund", tx)}
}

func (_c *MockDB_InsertRefund_Call) Run(run func(tx models.Refund)) *MockDB_InsertRefund_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Refund))
	})
	return _c
}

func (_c *MockDB_InsertRefund_Call) Return(_a0 primitive.ObjectID, _a1 error) *MockDB_InsertRefund_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_InsertRefund_Call) RunAndReturn(run func(models.Refund) (primitive.ObjectID, error)) *MockDB_InsertRefund_Call {
	_c.Call.Return(run)
	return _c
}

// InsertTransaction provides a mock function with given fields: tx
func (_m *MockDB) InsertTransaction(tx models.Transaction) (primitive.ObjectID, error) {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for InsertTransaction")
	}

	var r0 primitive.ObjectID
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Transaction) (primitive.ObjectID, error)); ok {
		return rf(tx)
	}
	if rf, ok := ret.Get(0).(func(models.Transaction) primitive.ObjectID); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(primitive.ObjectID)
		}
	}

	if rf, ok := ret.Get(1).(func(models.Transaction) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_InsertTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertTransaction'
type MockDB_InsertTransaction_Call struct {
	*mock.Call
}

// InsertTransaction is a helper method to define mock.On call
//   - tx models.Transaction
func (_e *MockDB_Expecter) InsertTransaction(tx interface{}) *MockDB_InsertTransaction_Call {
	return &MockDB_InsertTransaction_Call{Call: _e.mock.On("InsertTransaction", tx)}
}

func (_c *MockDB_InsertTransaction_Call) Run(run func(tx models.Transaction)) *MockDB_InsertTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Transaction))
	})
	return _c
}

func (_c *MockDB_InsertTransaction_Call) Return(_a0 primitive.ObjectID, _a1 error) *MockDB_InsertTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_InsertTransaction_Call) RunAndReturn(run func(models.Transaction) (primitive.ObjectID, error)) *MockDB_InsertTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// LockReadSequences provides a mock function with given fields:
func (_m *MockDB) LockReadSequences() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LockReadSequences")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_LockReadSequences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockReadSequences'
type MockDB_LockReadSequences_Call struct {
	*mock.Call
}

// LockReadSequences is a helper method to define mock.On call
func (_e *MockDB_Expecter) LockReadSequences() *MockDB_LockReadSequences_Call {
	return &MockDB_LockReadSequences_Call{Call: _e.mock.On("LockReadSequences")}
}

func (_c *MockDB_LockReadSequences_Call) Run(run func()) *MockDB_LockReadSequences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDB_LockReadSequences_Call) Return(lockID string, err error) *MockDB_LockReadSequences_Call {
	_c.Call.Return(lockID, err)
	return _c
}

func (_c *MockDB_LockReadSequences_Call) RunAndReturn(run func() (string, error)) *MockDB_LockReadSequences_Call {
	_c.Call.Return(run)
	return _c
}

// LockWriteMessage provides a mock function with given fields: messageDoc
func (_m *MockDB) LockWriteMessage(messageDoc *models.Message) (string, error) {
	ret := _m.Called(messageDoc)

	if len(ret) == 0 {
		panic("no return value specified for LockWriteMessage")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*models.Message) (string, error)); ok {
		return rf(messageDoc)
	}
	if rf, ok := ret.Get(0).(func(*models.Message) string); ok {
		r0 = rf(messageDoc)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*models.Message) error); ok {
		r1 = rf(messageDoc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_LockWriteMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockWriteMessage'
type MockDB_LockWriteMessage_Call struct {
	*mock.Call
}

// LockWriteMessage is a helper method to define mock.On call
//   - messageDoc *models.Message
func (_e *MockDB_Expecter) LockWriteMessage(messageDoc interface{}) *MockDB_LockWriteMessage_Call {
	return &MockDB_LockWriteMessage_Call{Call: _e.mock.On("LockWriteMessage", messageDoc)}
}

func (_c *MockDB_LockWriteMessage_Call) Run(run func(messageDoc *models.Message)) *MockDB_LockWriteMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*models.Message))
	})
	return _c
}

func (_c *MockDB_LockWriteMessage_Call) Return(lockID string, err error) *MockDB_LockWriteMessage_Call {
	_c.Call.Return(lockID, err)
	return _c
}

func (_c *MockDB_LockWriteMessage_Call) RunAndReturn(run func(*models.Message) (string, error)) *MockDB_LockWriteMessage_Call {
	_c.Call.Return(run)
	return _c
}

// LockWriteRefund provides a mock function with given fields: refundDoc
func (_m *MockDB) LockWriteRefund(refundDoc *models.Refund) (string, error) {
	ret := _m.Called(refundDoc)

	if len(ret) == 0 {
		panic("no return value specified for LockWriteRefund")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*models.Refund) (string, error)); ok {
		return rf(refundDoc)
	}
	if rf, ok := ret.Get(0).(func(*models.Refund) string); ok {
		r0 = rf(refundDoc)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*models.Refund) error); ok {
		r1 = rf(refundDoc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_LockWriteRefund_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockWriteRefund'
type MockDB_LockWriteRefund_Call struct {
	*mock.Call
}

// LockWriteRefund is a helper method to define mock.On call
//   - refundDoc *models.Refund
func (_e *MockDB_Expecter) LockWriteRefund(refundDoc interface{}) *MockDB_LockWriteRefund_Call {
	return &MockDB_LockWriteRefund_Call{Call: _e.mock.On("LockWriteRefund", refundDoc)}
}

func (_c *MockDB_LockWriteRefund_Call) Run(run func(refundDoc *models.Refund)) *MockDB_LockWriteRefund_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*models.Refund))
	})
	return _c
}

func (_c *MockDB_LockWriteRefund_Call) Return(lockID string, err error) *MockDB_LockWriteRefund_Call {
	_c.Call.Return(lockID, err)
	return _c
}

func (_c *MockDB_LockWriteRefund_Call) RunAndReturn(run func(*models.Refund) (string, error)) *MockDB_LockWriteRefund_Call {
	_c.Call.Return(run)
	return _c
}

// LockWriteSequence provides a mock function with given fields:
func (_m *MockDB) LockWriteSequence() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LockWriteSequence")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_LockWriteSequence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockWriteSequence'
type MockDB_LockWriteSequence_Call struct {
	*mock.Call
}

// LockWriteSequence is a helper method to define mock.On call
func (_e *MockDB_Expecter) LockWriteSequence() *MockDB_LockWriteSequence_Call {
	return &MockDB_LockWriteSequence_Call{Call: _e.mock.On("LockWriteSequence")}
}

func (_c *MockDB_LockWriteSequence_Call) Run(run func()) *MockDB_LockWriteSequence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDB_LockWriteSequence_Call) Return(lockID string, err error) *MockDB_LockWriteSequence_Call {
	_c.Call.Return(lockID, err)
	return _c
}

func (_c *MockDB_LockWriteSequence_Call) RunAndReturn(run func() (string, error)) *MockDB_LockWriteSequence_Call {
	_c.Call.Return(run)
	return _c
}

// LockWriteTransaction provides a mock function with given fields: txDoc
func (_m *MockDB) LockWriteTransaction(txDoc *models.Transaction) (string, error) {
	ret := _m.Called(txDoc)

	if len(ret) == 0 {
		panic("no return value specified for LockWriteTransaction")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*models.Transaction) (string, error)); ok {
		return rf(txDoc)
	}
	if rf, ok := ret.Get(0).(func(*models.Transaction) string); ok {
		r0 = rf(txDoc)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*models.Transaction) error); ok {
		r1 = rf(txDoc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_LockWriteTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockWriteTransaction'
type MockDB_LockWriteTransaction_Call struct {
	*mock.Call
}

// LockWriteTransaction is a helper method to define mock.On call
//   - txDoc *models.Transaction
func (_e *MockDB_Expecter) LockWriteTransaction(txDoc interface{}) *MockDB_LockWriteTransaction_Call {
	return &MockDB_LockWriteTransaction_Call{Call: _e.mock.On("LockWriteTransaction", txDoc)}
}

func (_c *MockDB_LockWriteTransaction_Call) Run(run func(txDoc *models.Transaction)) *MockDB_LockWriteTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*models.Transaction))
	})
	return _c
}

func (_c *MockDB_LockWriteTransaction_Call) Return(lockID string, err error) *MockDB_LockWriteTransaction_Call {
	_c.Call.Return(lockID, err)
	return _c
}

func (_c *MockDB_LockWriteTransaction_Call) RunAndReturn(run func(*models.Transaction) (string, error)) *MockDB_LockWriteTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewCosmosTransaction provides a mock function with given fields: txRes, chain, fromAddress, toAddress, txStatus
func (_m *MockDB) NewCosmosTransaction(txRes *types.TxResponse, chain models.Chain, fromAddress []byte, toAddress []byte, txStatus models.TransactionStatus) (models.Transaction, error) {
	ret := _m.Called(txRes, chain, fromAddress, toAddress, txStatus)

	if len(ret) == 0 {
		panic("no return value specified for NewCosmosTransaction")
	}

	var r0 models.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*types.TxResponse, models.Chain, []byte, []byte, models.TransactionStatus) (models.Transaction, error)); ok {
		return rf(txRes, chain, fromAddress, toAddress, txStatus)
	}
	if rf, ok := ret.Get(0).(func(*types.TxResponse, models.Chain, []byte, []byte, models.TransactionStatus) models.Transaction); ok {
		r0 = rf(txRes, chain, fromAddress, toAddress, txStatus)
	} else {
		r0 = ret.Get(0).(models.Transaction)
	}

	if rf, ok := ret.Get(1).(func(*types.TxResponse, models.Chain, []byte, []byte, models.TransactionStatus) error); ok {
		r1 = rf(txRes, chain, fromAddress, toAddress, txStatus)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_NewCosmosTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewCosmosTransaction'
type MockDB_NewCosmosTransaction_Call struct {
	*mock.Call
}

// NewCosmosTransaction is a helper method to define mock.On call
//   - txRes *types.TxResponse
//   - chain models.Chain
//   - fromAddress []byte
//   - toAddress []byte
//   - txStatus models.TransactionStatus
func (_e *MockDB_Expecter) NewCosmosTransaction(txRes interface{}, chain interface{}, fromAddress interface{}, toAddress interface{}, txStatus interface{}) *MockDB_NewCosmosTransaction_Call {
	return &MockDB_NewCosmosTransaction_Call{Call: _e.mock.On("NewCosmosTransaction", txRes, chain, fromAddress, toAddress, txStatus)}
}

func (_c *MockDB_NewCosmosTransaction_Call) Run(run func(txRes *types.TxResponse, chain models.Chain, fromAddress []byte, toAddress []byte, txStatus models.TransactionStatus)) *MockDB_NewCosmosTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.TxResponse), args[1].(models.Chain), args[2].([]byte), args[3].([]byte), args[4].(models.TransactionStatus))
	})
	return _c
}

func (_c *MockDB_NewCosmosTransaction_Call) Return(_a0 models.Transaction, _a1 error) *MockDB_NewCosmosTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_NewCosmosTransaction_Call) RunAndReturn(run func(*types.TxResponse, models.Chain, []byte, []byte, models.TransactionStatus) (models.Transaction, error)) *MockDB_NewCosmosTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewEthereumTransaction provides a mock function with given fields: tx, toAddress, receipt, chain, txStatus
func (_m *MockDB) NewEthereumTransaction(tx *coretypes.Transaction, toAddress []byte, receipt *coretypes.Receipt, chain models.Chain, txStatus models.TransactionStatus) (models.Transaction, error) {
	ret := _m.Called(tx, toAddress, receipt, chain, txStatus)

	if len(ret) == 0 {
		panic("no return value specified for NewEthereumTransaction")
	}

	var r0 models.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*coretypes.Transaction, []byte, *coretypes.Receipt, models.Chain, models.TransactionStatus) (models.Transaction, error)); ok {
		return rf(tx, toAddress, receipt, chain, txStatus)
	}
	if rf, ok := ret.Get(0).(func(*coretypes.Transaction, []byte, *coretypes.Receipt, models.Chain, models.TransactionStatus) models.Transaction); ok {
		r0 = rf(tx, toAddress, receipt, chain, txStatus)
	} else {
		r0 = ret.Get(0).(models.Transaction)
	}

	if rf, ok := ret.Get(1).(func(*coretypes.Transaction, []byte, *coretypes.Receipt, models.Chain, models.TransactionStatus) error); ok {
		r1 = rf(tx, toAddress, receipt, chain, txStatus)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_NewEthereumTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewEthereumTransaction'
type MockDB_NewEthereumTransaction_Call struct {
	*mock.Call
}

// NewEthereumTransaction is a helper method to define mock.On call
//   - tx *coretypes.Transaction
//   - toAddress []byte
//   - receipt *coretypes.Receipt
//   - chain models.Chain
//   - txStatus models.TransactionStatus
func (_e *MockDB_Expecter) NewEthereumTransaction(tx interface{}, toAddress interface{}, receipt interface{}, chain interface{}, txStatus interface{}) *MockDB_NewEthereumTransaction_Call {
	return &MockDB_NewEthereumTransaction_Call{Call: _e.mock.On("NewEthereumTransaction", tx, toAddress, receipt, chain, txStatus)}
}

func (_c *MockDB_NewEthereumTransaction_Call) Run(run func(tx *coretypes.Transaction, toAddress []byte, receipt *coretypes.Receipt, chain models.Chain, txStatus models.TransactionStatus)) *MockDB_NewEthereumTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*coretypes.Transaction), args[1].([]byte), args[2].(*coretypes.Receipt), args[3].(models.Chain), args[4].(models.TransactionStatus))
	})
	return _c
}

func (_c *MockDB_NewEthereumTransaction_Call) Return(_a0 models.Transaction, _a1 error) *MockDB_NewEthereumTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_NewEthereumTransaction_Call) RunAndReturn(run func(*coretypes.Transaction, []byte, *coretypes.Receipt, models.Chain, models.TransactionStatus) (models.Transaction, error)) *MockDB_NewEthereumTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewMessage provides a mock function with given fields: txDoc, content, status
func (_m *MockDB) NewMessage(txDoc *models.Transaction, content models.MessageContent, status models.MessageStatus) (models.Message, error) {
	ret := _m.Called(txDoc, content, status)

	if len(ret) == 0 {
		panic("no return value specified for NewMessage")
	}

	var r0 models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(*models.Transaction, models.MessageContent, models.MessageStatus) (models.Message, error)); ok {
		return rf(txDoc, content, status)
	}
	if rf, ok := ret.Get(0).(func(*models.Transaction, models.MessageContent, models.MessageStatus) models.Message); ok {
		r0 = rf(txDoc, content, status)
	} else {
		r0 = ret.Get(0).(models.Message)
	}

	if rf, ok := ret.Get(1).(func(*models.Transaction, models.MessageContent, models.MessageStatus) error); ok {
		r1 = rf(txDoc, content, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_NewMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewMessage'
type MockDB_NewMessage_Call struct {
	*mock.Call
}

// NewMessage is a helper method to define mock.On call
//   - txDoc *models.Transaction
//   - content models.MessageContent
//   - status models.MessageStatus
func (_e *MockDB_Expecter) NewMessage(txDoc interface{}, content interface{}, status interface{}) *MockDB_NewMessage_Call {
	return &MockDB_NewMessage_Call{Call: _e.mock.On("NewMessage", txDoc, content, status)}
}

func (_c *MockDB_NewMessage_Call) Run(run func(txDoc *models.Transaction, content models.MessageContent, status models.MessageStatus)) *MockDB_NewMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*models.Transaction), args[1].(models.MessageContent), args[2].(models.MessageStatus))
	})
	return _c
}

func (_c *MockDB_NewMessage_Call) Return(_a0 models.Message, _a1 error) *MockDB_NewMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_NewMessage_Call) RunAndReturn(run func(*models.Transaction, models.MessageContent, models.MessageStatus) (models.Message, error)) *MockDB_NewMessage_Call {
	_c.Call.Return(run)
	return _c
}

// NewMessageBody provides a mock function with given fields: senderAddress, amount, recipientAddress
func (_m *MockDB) NewMessageBody(senderAddress []byte, amount *big.Int, recipientAddress []byte) (models.MessageBody, error) {
	ret := _m.Called(senderAddress, amount, recipientAddress)

	if len(ret) == 0 {
		panic("no return value specified for NewMessageBody")
	}

	var r0 models.MessageBody
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, *big.Int, []byte) (models.MessageBody, error)); ok {
		return rf(senderAddress, amount, recipientAddress)
	}
	if rf, ok := ret.Get(0).(func([]byte, *big.Int, []byte) models.MessageBody); ok {
		r0 = rf(senderAddress, amount, recipientAddress)
	} else {
		r0 = ret.Get(0).(models.MessageBody)
	}

	if rf, ok := ret.Get(1).(func([]byte, *big.Int, []byte) error); ok {
		r1 = rf(senderAddress, amount, recipientAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_NewMessageBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewMessageBody'
type MockDB_NewMessageBody_Call struct {
	*mock.Call
}

// NewMessageBody is a helper method to define mock.On call
//   - senderAddress []byte
//   - amount *big.Int
//   - recipientAddress []byte
func (_e *MockDB_Expecter) NewMessageBody(senderAddress interface{}, amount interface{}, recipientAddress interface{}) *MockDB_NewMessageBody_Call {
	return &MockDB_NewMessageBody_Call{Call: _e.mock.On("NewMessageBody", senderAddress, amount, recipientAddress)}
}

func (_c *MockDB_NewMessageBody_Call) Run(run func(senderAddress []byte, amount *big.Int, recipientAddress []byte)) *MockDB_NewMessageBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(*big.Int), args[2].([]byte))
	})
	return _c
}

func (_c *MockDB_NewMessageBody_Call) Return(_a0 models.MessageBody, _a1 error) *MockDB_NewMessageBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_NewMessageBody_Call) RunAndReturn(run func([]byte, *big.Int, []byte) (models.MessageBody, error)) *MockDB_NewMessageBody_Call {
	_c.Call.Return(run)
	return _c
}

// NewMessageContent provides a mock function with given fields: nonce, originDomain, senderAddress, destinationDomain, recipientAddress, messageBody
func (_m *MockDB) NewMessageContent(nonce uint32, originDomain uint32, senderAddress []byte, destinationDomain uint32, recipientAddress []byte, messageBody models.MessageBody) (models.MessageContent, error) {
	ret := _m.Called(nonce, originDomain, senderAddress, destinationDomain, recipientAddress, messageBody)

	if len(ret) == 0 {
		panic("no return value specified for NewMessageContent")
	}

	var r0 models.MessageContent
	var r1 error
	if rf, ok := ret.Get(0).(func(uint32, uint32, []byte, uint32, []byte, models.MessageBody) (models.MessageContent, error)); ok {
		return rf(nonce, originDomain, senderAddress, destinationDomain, recipientAddress, messageBody)
	}
	if rf, ok := ret.Get(0).(func(uint32, uint32, []byte, uint32, []byte, models.MessageBody) models.MessageContent); ok {
		r0 = rf(nonce, originDomain, senderAddress, destinationDomain, recipientAddress, messageBody)
	} else {
		r0 = ret.Get(0).(models.MessageContent)
	}

	if rf, ok := ret.Get(1).(func(uint32, uint32, []byte, uint32, []byte, models.MessageBody) error); ok {
		r1 = rf(nonce, originDomain, senderAddress, destinationDomain, recipientAddress, messageBody)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_NewMessageContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewMessageContent'
type MockDB_NewMessageContent_Call struct {
	*mock.Call
}

// NewMessageContent is a helper method to define mock.On call
//   - nonce uint32
//   - originDomain uint32
//   - senderAddress []byte
//   - destinationDomain uint32
//   - recipientAddress []byte
//   - messageBody models.MessageBody
func (_e *MockDB_Expecter) NewMessageContent(nonce interface{}, originDomain interface{}, senderAddress interface{}, destinationDomain interface{}, recipientAddress interface{}, messageBody interface{}) *MockDB_NewMessageContent_Call {
	return &MockDB_NewMessageContent_Call{Call: _e.mock.On("NewMessageContent", nonce, originDomain, senderAddress, destinationDomain, recipientAddress, messageBody)}
}

func (_c *MockDB_NewMessageContent_Call) Run(run func(nonce uint32, originDomain uint32, senderAddress []byte, destinationDomain uint32, recipientAddress []byte, messageBody models.MessageBody)) *MockDB_NewMessageContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint32), args[1].(uint32), args[2].([]byte), args[3].(uint32), args[4].([]byte), args[5].(models.MessageBody))
	})
	return _c
}

func (_c *MockDB_NewMessageContent_Call) Return(_a0 models.MessageContent, _a1 error) *MockDB_NewMessageContent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_NewMessageContent_Call) RunAndReturn(run func(uint32, uint32, []byte, uint32, []byte, models.MessageBody) (models.MessageContent, error)) *MockDB_NewMessageContent_Call {
	_c.Call.Return(run)
	return _c
}

// NewRefund provides a mock function with given fields: txRes, txDoc, recipientAddress, amountCoin
func (_m *MockDB) NewRefund(txRes *types.TxResponse, txDoc *models.Transaction, recipientAddress []byte, amountCoin types.Coin) (models.Refund, error) {
	ret := _m.Called(txRes, txDoc, recipientAddress, amountCoin)

	if len(ret) == 0 {
		panic("no return value specified for NewRefund")
	}

	var r0 models.Refund
	var r1 error
	if rf, ok := ret.Get(0).(func(*types.TxResponse, *models.Transaction, []byte, types.Coin) (models.Refund, error)); ok {
		return rf(txRes, txDoc, recipientAddress, amountCoin)
	}
	if rf, ok := ret.Get(0).(func(*types.TxResponse, *models.Transaction, []byte, types.Coin) models.Refund); ok {
		r0 = rf(txRes, txDoc, recipientAddress, amountCoin)
	} else {
		r0 = ret.Get(0).(models.Refund)
	}

	if rf, ok := ret.Get(1).(func(*types.TxResponse, *models.Transaction, []byte, types.Coin) error); ok {
		r1 = rf(txRes, txDoc, recipientAddress, amountCoin)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_NewRefund_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewRefund'
type MockDB_NewRefund_Call struct {
	*mock.Call
}

// NewRefund is a helper method to define mock.On call
//   - txRes *types.TxResponse
//   - txDoc *models.Transaction
//   - recipientAddress []byte
//   - amountCoin types.Coin
func (_e *MockDB_Expecter) NewRefund(txRes interface{}, txDoc interface{}, recipientAddress interface{}, amountCoin interface{}) *MockDB_NewRefund_Call {
	return &MockDB_NewRefund_Call{Call: _e.mock.On("NewRefund", txRes, txDoc, recipientAddress, amountCoin)}
}

func (_c *MockDB_NewRefund_Call) Run(run func(txRes *types.TxResponse, txDoc *models.Transaction, recipientAddress []byte, amountCoin types.Coin)) *MockDB_NewRefund_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.TxResponse), args[1].(*models.Transaction), args[2].([]byte), args[3].(types.Coin))
	})
	return _c
}

func (_c *MockDB_NewRefund_Call) Return(_a0 models.Refund, _a1 error) *MockDB_NewRefund_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_NewRefund_Call) RunAndReturn(run func(*types.TxResponse, *models.Transaction, []byte, types.Coin) (models.Refund, error)) *MockDB_NewRefund_Call {
	_c.Call.Return(run)
	return _c
}

// Unlock provides a mock function with given fields: lockID
func (_m *MockDB) Unlock(lockID string) error {
	ret := _m.Called(lockID)

	if len(ret) == 0 {
		panic("no return value specified for Unlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(lockID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDB_Unlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unlock'
type MockDB_Unlock_Call struct {
	*mock.Call
}

// Unlock is a helper method to define mock.On call
//   - lockID string
func (_e *MockDB_Expecter) Unlock(lockID interface{}) *MockDB_Unlock_Call {
	return &MockDB_Unlock_Call{Call: _e.mock.On("Unlock", lockID)}
}

func (_c *MockDB_Unlock_Call) Run(run func(lockID string)) *MockDB_Unlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockDB_Unlock_Call) Return(_a0 error) *MockDB_Unlock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDB_Unlock_Call) RunAndReturn(run func(string) error) *MockDB_Unlock_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMessage provides a mock function with given fields: messageID, update
func (_m *MockDB) UpdateMessage(messageID *primitive.ObjectID, update primitive.M) error {
	ret := _m.Called(messageID, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*primitive.ObjectID, primitive.M) error); ok {
		r0 = rf(messageID, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDB_UpdateMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMessage'
type MockDB_UpdateMessage_Call struct {
	*mock.Call
}

// UpdateMessage is a helper method to define mock.On call
//   - messageID *primitive.ObjectID
//   - update primitive.M
func (_e *MockDB_Expecter) UpdateMessage(messageID interface{}, update interface{}) *MockDB_UpdateMessage_Call {
	return &MockDB_UpdateMessage_Call{Call: _e.mock.On("UpdateMessage", messageID, update)}
}

func (_c *MockDB_UpdateMessage_Call) Run(run func(messageID *primitive.ObjectID, update primitive.M)) *MockDB_UpdateMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*primitive.ObjectID), args[1].(primitive.M))
	})
	return _c
}

func (_c *MockDB_UpdateMessage_Call) Return(_a0 error) *MockDB_UpdateMessage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDB_UpdateMessage_Call) RunAndReturn(run func(*primitive.ObjectID, primitive.M) error) *MockDB_UpdateMessage_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMessageByMessageID provides a mock function with given fields: messageID, update
func (_m *MockDB) UpdateMessageByMessageID(messageID [32]byte, update primitive.M) (primitive.ObjectID, error) {
	ret := _m.Called(messageID, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMessageByMessageID")
	}

	var r0 primitive.ObjectID
	var r1 error
	if rf, ok := ret.Get(0).(func([32]byte, primitive.M) (primitive.ObjectID, error)); ok {
		return rf(messageID, update)
	}
	if rf, ok := ret.Get(0).(func([32]byte, primitive.M) primitive.ObjectID); ok {
		r0 = rf(messageID, update)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(primitive.ObjectID)
		}
	}

	if rf, ok := ret.Get(1).(func([32]byte, primitive.M) error); ok {
		r1 = rf(messageID, update)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDB_UpdateMessageByMessageID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMessageByMessageID'
type MockDB_UpdateMessageByMessageID_Call struct {
	*mock.Call
}

// UpdateMessageByMessageID is a helper method to define mock.On call
//   - messageID [32]byte
//   - update primitive.M
func (_e *MockDB_Expecter) UpdateMessageByMessageID(messageID interface{}, update interface{}) *MockDB_UpdateMessageByMessageID_Call {
	return &MockDB_UpdateMessageByMessageID_Call{Call: _e.mock.On("UpdateMessageByMessageID", messageID, update)}
}

func (_c *MockDB_UpdateMessageByMessageID_Call) Run(run func(messageID [32]byte, update primitive.M)) *MockDB_UpdateMessageByMessageID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([32]byte), args[1].(primitive.M))
	})
	return _c
}

func (_c *MockDB_UpdateMessageByMessageID_Call) Return(_a0 primitive.ObjectID, _a1 error) *MockDB_UpdateMessageByMessageID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDB_UpdateMessageByMessageID_Call) RunAndReturn(run func([32]byte, primitive.M) (primitive.ObjectID, error)) *MockDB_UpdateMessageByMessageID_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRefund provides a mock function with given fields: refundID, update
func (_m *MockDB) UpdateRefund(refundID *primitive.ObjectID, update primitive.M) error {
	ret := _m.Called(refundID, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRefund")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*primitive.ObjectID, primitive.M) error); ok {
		r0 = rf(refundID, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDB_UpdateRefund_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRefund'
type MockDB_UpdateRefund_Call struct {
	*mock.Call
}

// UpdateRefund is a helper method to define mock.On call
//   - refundID *primitive.ObjectID
//   - update primitive.M
func (_e *MockDB_Expecter) UpdateRefund(refundID interface{}, update interface{}) *MockDB_UpdateRefund_Call {
	return &MockDB_UpdateRefund_Call{Call: _e.mock.On("UpdateRefund", refundID, update)}
}

func (_c *MockDB_UpdateRefund_Call) Run(run func(refundID *primitive.ObjectID, update primitive.M)) *MockDB_UpdateRefund_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*primitive.ObjectID), args[1].(primitive.M))
	})
	return _c
}

func (_c *MockDB_UpdateRefund_Call) Return(_a0 error) *MockDB_UpdateRefund_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDB_UpdateRefund_Call) RunAndReturn(run func(*primitive.ObjectID, primitive.M) error) *MockDB_UpdateRefund_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTransaction provides a mock function with given fields: txID, update
func (_m *MockDB) UpdateTransaction(txID *primitive.ObjectID, update primitive.M) error {
	ret := _m.Called(txID, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*primitive.ObjectID, primitive.M) error); ok {
		r0 = rf(txID, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDB_UpdateTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTransaction'
type MockDB_UpdateTransaction_Call struct {
	*mock.Call
}

// UpdateTransaction is a helper method to define mock.On call
//   - txID *primitive.ObjectID
//   - update primitive.M
func (_e *MockDB_Expecter) UpdateTransaction(txID interface{}, update interface{}) *MockDB_UpdateTransaction_Call {
	return &MockDB_UpdateTransaction_Call{Call: _e.mock.On("UpdateTransaction", txID, update)}
}

func (_c *MockDB_UpdateTransaction_Call) Run(run func(txID *primitive.ObjectID, update primitive.M)) *MockDB_UpdateTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*primitive.ObjectID), args[1].(primitive.M))
	})
	return _c
}

func (_c *MockDB_UpdateTransaction_Call) Return(_a0 error) *MockDB_UpdateTransaction_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDB_UpdateTransaction_Call) RunAndReturn(run func(*primitive.ObjectID, primitive.M) error) *MockDB_UpdateTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertNode provides a mock function with given fields: filter, onUpdate, onInsert
func (_m *MockDB) UpsertNode(filter interface{}, onUpdate interface{}, onInsert interface{}) error {
	ret := _m.Called(filter, onUpdate, onInsert)

	if len(ret) == 0 {
		panic("no return value specified for UpsertNode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}) error); ok {
		r0 = rf(filter, onUpdate, onInsert)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDB_UpsertNode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertNode'
type MockDB_UpsertNode_Call struct {
	*mock.Call
}

// UpsertNode is a helper method to define mock.On call
//   - filter interface{}
//   - onUpdate interface{}
//   - onInsert interface{}
func (_e *MockDB_Expecter) UpsertNode(filter interface{}, onUpdate interface{}, onInsert interface{}) *MockDB_UpsertNode_Call {
	return &MockDB_UpsertNode_Call{Call: _e.mock.On("UpsertNode", filter, onUpdate, onInsert)}
}

func (_c *MockDB_UpsertNode_Call) Run(run func(filter interface{}, onUpdate interface{}, onInsert interface{})) *MockDB_UpsertNode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *MockDB_UpsertNode_Call) Return(_a0 error) *MockDB_UpsertNode_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDB_UpsertNode_Call) RunAndReturn(run func(interface{}, interface{}, interface{}) error) *MockDB_UpsertNode_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDB creates a new instance of MockDB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDB(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDB {
	mock := &MockDB{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
